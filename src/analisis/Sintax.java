//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Thu Nov 07 01:04:48 CST 2024
//----------------------------------------------------
package analisis;

import java.awt.Color;
import java_cup.runtime.Symbol;
import java.util.HashMap;
import java.util.List;

/**
 * CUP v0.11a beta 20060608 generated parser.
 *
 * @version Thu Nov 07 01:04:48 CST 2024
 */
public class Sintax extends java_cup.runtime.lr_parser {

    /**
     * Default constructor.
     */
    public Sintax() {
        super();
    }

    /**
     * Constructor which sets the default scanner.
     */
    public Sintax(java_cup.runtime.Scanner s) {
        super(s);
    }

    /**
     * Constructor which sets the default scanner.
     */
    public Sintax(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {
        super(s, sf);
    }

    /**
     * Production table.
     */
    protected static final short _production_table[][]
            = unpackFromStrings(new String[]{
        "\000\040\000\002\002\004\000\002\002\003\000\002\002"
        + "\003\000\002\002\003\000\002\002\003\000\002\002\003"
        + "\000\002\002\003\000\002\002\003\000\002\002\003\000"
        + "\002\002\003\000\002\002\003\000\002\002\003\000\002"
        + "\002\003\000\002\002\003\000\002\002\003\000\002\002"
        + "\003\000\002\003\013\000\002\004\012\000\002\004\013"
        + "\000\002\005\013\000\002\006\015\000\002\007\015\000"
        + "\002\010\015\000\002\011\015\000\002\012\011\000\002"
        + "\013\011\000\002\014\012\000\002\015\012\000\002\016"
        + "\015\000\002\017\015\000\002\020\006\000\002\021\006"
        + ""});

    /**
     * Access to production table.
     */
    public short[][] production_table() {
        return _production_table;
    }

    /**
     * Parse-action table.
     */
    protected static final short[][] _action_table
            = unpackFromStrings(new String[]{
        "\000\173\000\024\006\010\007\015\010\032\011\012\012"
        + "\034\013\006\014\011\015\022\016\013\001\002\000\004"
        + "\002\ufffe\001\002\000\004\002\uffff\001\002\000\004\004"
        + "\167\001\002\000\004\002\000\001\002\000\004\004\137"
        + "\001\002\000\004\004\122\001\002\000\004\004\111\001"
        + "\002\000\004\004\106\001\002\000\004\002\105\001\002"
        + "\000\004\004\070\001\002\000\004\002\ufff2\001\002\000"
        + "\004\002\ufffd\001\002\000\004\002\ufff9\001\002\000\004"
        + "\002\ufff7\001\002\000\004\004\065\001\002\000\004\002"
        + "\ufff5\001\002\000\004\002\ufffc\001\002\000\004\002\ufff3"
        + "\001\002\000\004\002\ufffa\001\002\000\004\002\ufffb\001"
        + "\002\000\004\002\ufff6\001\002\000\004\002\ufff8\001\002"
        + "\000\004\004\044\001\002\000\004\002\ufff4\001\002\000"
        + "\004\004\035\001\002\000\004\017\036\001\002\000\004"
        + "\004\037\001\002\000\004\023\040\001\002\000\004\004"
        + "\041\001\002\000\004\005\042\001\002\000\004\033\043"
        + "\001\002\000\004\002\uffe7\001\002\000\004\005\045\001"
        + "\002\000\004\030\046\001\002\000\006\017\050\032\047"
        + "\001\002\000\004\031\057\001\002\000\004\031\051\001"
        + "\002\000\004\004\052\001\002\000\004\023\053\001\002"
        + "\000\004\004\054\001\002\000\004\017\055\001\002\000"
        + "\004\033\056\001\002\000\004\002\uffeb\001\002\000\004"
        + "\004\060\001\002\000\004\023\061\001\002\000\004\004"
        + "\062\001\002\000\004\017\063\001\002\000\004\033\064"
        + "\001\002\000\004\002\uffea\001\002\000\004\005\066\001"
        + "\002\000\004\033\067\001\002\000\004\002\uffe3\001\002"
        + "\000\004\017\071\001\002\000\004\004\072\001\002\000"
        + "\004\023\073\001\002\000\004\004\074\001\002\000\004"
        + "\005\075\001\002\000\004\030\076\001\002\000\006\017"
        + "\100\032\077\001\002\000\004\031\103\001\002\000\004"
        + "\031\101\001\002\000\004\033\102\001\002\000\004\002"
        + "\uffed\001\002\000\004\033\104\001\002\000\004\002\uffec"
        + "\001\002\000\004\002\001\001\002\000\004\005\107\001"
        + "\002\000\004\033\110\001\002\000\004\002\uffe2\001\002"
        + "\000\004\005\112\001\002\000\004\030\113\001\002\000"
        + "\006\017\115\032\114\001\002\000\004\031\120\001\002"
        + "\000\004\031\116\001\002\000\004\033\117\001\002\000"
        + "\004\002\uffe9\001\002\000\004\033\121\001\002\000\004"
        + "\002\uffe8\001\002\000\004\022\123\001\002\000\004\004"
        + "\124\001\002\000\004\024\125\001\002\000\004\004\126"
        + "\001\002\000\004\005\127\001\002\000\004\030\130\001"
        + "\002\000\006\017\132\032\131\001\002\000\004\031\135"
        + "\001\002\000\004\031\133\001\002\000\004\033\134\001"
        + "\002\000\004\002\uffe5\001\002\000\004\033\136\001\002"
        + "\000\004\002\uffe4\001\002\000\010\025\141\026\140\027"
        + "\142\001\002\000\004\004\157\001\002\000\004\004\151"
        + "\001\002\000\004\004\143\001\002\000\004\005\144\001"
        + "\002\000\004\030\145\001\002\000\004\032\146\001\002"
        + "\000\004\031\147\001\002\000\004\033\150\001\002\000"
        + "\004\002\uffee\001\002\000\004\005\152\001\002\000\004"
        + "\030\153\001\002\000\004\017\154\001\002\000\004\031"
        + "\155\001\002\000\004\033\156\001\002\000\004\002\ufff1"
        + "\001\002\000\004\005\160\001\002\000\004\030\161\001"
        + "\002\000\006\017\163\031\162\001\002\000\004\033\166"
        + "\001\002\000\004\031\164\001\002\000\004\033\165\001"
        + "\002\000\004\002\uffef\001\002\000\004\002\ufff0\001\002"
        + "\000\004\020\170\001\002\000\004\004\171\001\002\000"
        + "\004\021\172\001\002\000\004\004\173\001\002\000\004"
        + "\005\174\001\002\000\004\033\175\001\002\000\004\002"
        + "\uffe6\001\002"});

    /**
     * Access to parse-action table.
     */
    public short[][] action_table() {
        return _action_table;
    }

    /** <code>reduce_goto</code> table.
     */
    protected static final short[][] _reduce_table
            = unpackFromStrings(new String[]{
        "\000\173\000\042\002\013\003\006\004\004\005\003\006"
        + "\016\007\023\010\026\011\025\012\017\013\030\014\020"
        + "\015\027\016\022\017\032\020\024\021\015\001\001\000"
        + "\002\001\001\000\002\001\001\000\002\001\001\000\002"
        + "\001\001\000\002\001\001\000\002\001\001\000\002\001"
        + "\001\000\002\001\001\000\002\001\001\000\002\001\001"
        + "\000\002\001\001\000\002\001\001\000\002\001\001\000"
        + "\002\001\001\000\002\001\001\000\002\001\001\000\002"
        + "\001\001\000\002\001\001\000\002\001\001\000\002\001"
        + "\001\000\002\001\001\000\002\001\001\000\002\001\001"
        + "\000\002\001\001\000\002\001\001\000\002\001\001\000"
        + "\002\001\001\000\002\001\001\000\002\001\001\000\002"
        + "\001\001\000\002\001\001\000\002\001\001\000\002\001"
        + "\001\000\002\001\001\000\002\001\001\000\002\001\001"
        + "\000\002\001\001\000\002\001\001\000\002\001\001\000"
        + "\002\001\001\000\002\001\001\000\002\001\001\000\002"
        + "\001\001\000\002\001\001\000\002\001\001\000\002\001"
        + "\001\000\002\001\001\000\002\001\001\000\002\001\001"
        + "\000\002\001\001\000\002\001\001\000\002\001\001\000"
        + "\002\001\001\000\002\001\001\000\002\001\001\000\002"
        + "\001\001\000\002\001\001\000\002\001\001\000\002\001"
        + "\001\000\002\001\001\000\002\001\001\000\002\001\001"
        + "\000\002\001\001\000\002\001\001\000\002\001\001\000"
        + "\002\001\001\000\002\001\001\000\002\001\001\000\002"
        + "\001\001\000\002\001\001\000\002\001\001\000\002\001"
        + "\001\000\002\001\001\000\002\001\001\000\002\001\001"
        + "\000\002\001\001\000\002\001\001\000\002\001\001\000"
        + "\002\001\001\000\002\001\001\000\002\001\001\000\002"
        + "\001\001\000\002\001\001\000\002\001\001\000\002\001"
        + "\001\000\002\001\001\000\002\001\001\000\002\001\001"
        + "\000\002\001\001\000\002\001\001\000\002\001\001\000"
        + "\002\001\001\000\002\001\001\000\002\001\001\000\002"
        + "\001\001\000\002\001\001\000\002\001\001\000\002\001"
        + "\001\000\002\001\001\000\002\001\001\000\002\001\001"
        + "\000\002\001\001\000\002\001\001\000\002\001\001\000"
        + "\002\001\001\000\002\001\001\000\002\001\001\000\002"
        + "\001\001\000\002\001\001\000\002\001\001\000\002\001"
        + "\001\000\002\001\001\000\002\001\001\000\002\001\001"
        + "\000\002\001\001\000\002\001\001\000\002\001\001\000"
        + "\002\001\001\000\002\001\001\000\002\001\001\000\002"
        + "\001\001\000\002\001\001"});

    /**
     * Access to <code>reduce_goto</code> table.
     */
    public short[][] reduce_table() {
        return _reduce_table;
    }

    /**
     * Instance of action encapsulation class.
     */
    protected CUP$Sintax$actions action_obj;

    /**
     * Action encapsulation object initializer.
     */
    protected void init_actions() {
        action_obj = new CUP$Sintax$actions(this);
    }

    /**
     * Invoke a user supplied parse action.
     */
    public java_cup.runtime.Symbol do_action(
            int act_num,
            java_cup.runtime.lr_parser parser,
            java.util.Stack stack,
            int top)
            throws java.lang.Exception {
        /* call code in generated class */
        return action_obj.CUP$Sintax$do_action(act_num, parser, stack, top);
    }

    /**
     * Indicates start state.
     */
    public int start_state() {
        return 0;
    }

    /**
     * Indicates start production.
     */
    public int start_production() {
        return 0;
    }

    /** <code>EOF</code> Symbol index.
     */
    public int EOF_sym() {
        return 0;
    }

    /** <code>error</code> Symbol index.
     */
    public int error_sym() {
        return 1;
    }

    // Tus variables y métodos personalizados aquí
    private Panel panel; // Referencia al panel

    // Método para establecer el panel desde fuera
    public void setPanel(Panel panel) {
        this.panel = panel;
    }

    // Acceso a la instancia del panel desde las acciones del parser
    public Panel getPanel() {
        return this.panel;
    }
    private boolean matrizCreadaExitosamente = false;

// Método para marcar que la matriz fue creada exitosamente
    public void setMatrizCreadaExitosamente() {
        this.matrizCreadaExitosamente = true;
    }

    public boolean isMatrizCreadaExitosamente() {
        return matrizCreadaExitosamente;
    }

    public void setInstrucciones(HashMap<String, String> instrucciones) {
        this.instrucciones = instrucciones;
        System.out.println("HashMap recibido en Sintax: " + this.instrucciones.keySet());
    }

    // HashMap para almacenar identificadores y acciones
    private HashMap<String, String> instrucciones = new HashMap<>();

    // Método para manejar la creación de una matriz directamente en Java
    public void crearMatriz(String identificador, int filas, int columnas) {
        if (filas > 0 && columnas > 0) {
            agregarInstruccion(identificador, "crearMatriz");
            System.out.println("Matriz '" + identificador + "' de " + filas + "x" + columnas + " creada.");
            setMatrizCreadaExitosamente(); // Marca el éxito de la creación de la matriz

            // Llama al método para pintar la matriz en el panel
            Panel panel = getPanel();
            if (panel != null) {
                Color color = panel.generarColorAleatorio(); // Genera un color aleatorio para la matriz
                panel.pintarMatriz(filas, columnas, color, identificador); // Pinta la matriz
            }
        } else {
            System.out.println("Error: Las dimensiones deben ser mayores que cero.");
        }
    }

    // Método para analizar la entrada de forma manual
    public void analizarEntrada(String entrada) {
        // Expresión regular para verificar estructura general de la instrucción
        if (entrada.matches("(?i)\\s*crear\\s+matriz\\s+\\w+\\s*\\[\\d+\\s*,\\s*\\d+\\s*];?\\s*")) {
            try {
                // Dividimos la entrada en partes
                String[] partes = entrada.split("[\\[\\],;]");

                // Obtenemos las palabras de la primera parte para el identificador
                String[] palabras = partes[0].trim().split("\\s+");
                if (palabras.length < 3) {
                    System.out.println("Error: Formato de instrucción incorrecto.");
                    return;
                }

                String identificador = palabras[2]; // Extraemos el identificador

                // Expresión regular para validar identificador
                if (!identificador.matches("^[A-Za-z][A-Za-z0-9_]*$")) {
                    System.out.println("Error: Identificador inválido. Debe comenzar con una letra y puede contener letras, números o '_'.");
                    return;
                }

                // Convertimos filas y columnas a enteros
                int filas = Integer.parseInt(partes[1].trim());
                int columnas = Integer.parseInt(partes[2].trim());

                // Llamamos al método para crear la matriz
                crearMatriz(identificador, filas, columnas);

            } catch (NumberFormatException e) {
                System.out.println("Error: Las dimensiones de la matriz deben ser números enteros.");
            } catch (ArrayIndexOutOfBoundsException e) {
                System.out.println("Error: Formato de instrucción incorrecto.");
            }
        } else {
            System.out.println("La instruccion no es una matriz");
        }
    }

    public HashMap<String, String> getInstrucciones() {
        return instrucciones;
    }

    public void agregarInstruccion(String identificador, String accion) {
        instrucciones.put(identificador, accion);
        System.out.println("Identificador agregado: " + identificador);
        System.out.println("Identificadores actuales: " + instrucciones.keySet());
    }
    // Agrega esto en la clase Sintax
    private HashMap<String, List<int[]>> celdasPorIdentificador = new HashMap<>();

// Método para obtener el HashMap de celdas por identificador
    public HashMap<String, List<int[]>> getCeldasPorIdentificador() {
        return celdasPorIdentificador;
    }

// Método para agregar celdas a un identificador específico
    public void agregarCeldasPorIdentificador(String identificador, List<int[]> celdas) {
        celdasPorIdentificador.put(identificador, celdas);
    }

    private Symbol s;

    public void syntax_error(Symbol s) {
        this.s = s;
    }

    public Symbol getS() {
        return this.s;
    }

}

/**
 * Cup generated class to encapsulate user supplied action code.
 */
class CUP$Sintax$actions {

    private final Sintax parser;

    /**
     * Constructor
     */
    CUP$Sintax$actions(Sintax parser) {
        this.parser = parser;
    }

    /**
     * Method with the actual generated action code.
     */
    public final java_cup.runtime.Symbol CUP$Sintax$do_action(
            int CUP$Sintax$act_num,
            java_cup.runtime.lr_parser CUP$Sintax$parser,
            java.util.Stack CUP$Sintax$stack,
            int CUP$Sintax$top)
            throws java.lang.Exception {
        /* Symbol object for return from actions */
        java_cup.runtime.Symbol CUP$Sintax$result;

        /* select the action based on the action number */
        switch (CUP$Sintax$act_num) {
            /*. . . . . . . . . . . . . . . . . . . .*/
            case 31: // vaciarEstructura ::= VACIAR ESPACIO IDENTIFICADOR FINAL
            {
                Object RESULT = null;
                String identificador = ((Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)).value.toString();

                Panel panel = parser.getPanel();
                if (panel != null) {

                    panel.vaciarCeldasPorIdentificador(identificador);
                    System.out.println("Celdas asociadas al identificador '" + identificador + "' vaciadas.");
                } else {
                    System.out.println("Error: Panel no disponible.");
                }

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("vaciarEstructura", 15, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 3)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;


            /*. . . . . . . . . . . . . . . . . . . .*/
            case 30: // mostrarEstructura ::= MOSTRAR ESPACIO IDENTIFICADOR FINAL
            {
                Object RESULT = null;
                String identificador = ((Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)).value.toString();

                Panel panel = parser.getPanel();
                if (panel != null) {
                    panel.zoomEnCeldasPorIdentificador(identificador);
                    RESULT = "Se ha hecho zoom en las celdas asociadas al identificador '" + identificador + "'.";
                } else {
                    RESULT = "Error: Panel no disponible.";
                }

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("mostrarEstructura", 14, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 3)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;


            /*. . . . . . . . . . . . . . . . . . . .*/
            case 29: // pintarMatriz ::= PINTAR ESPACIO COLOR ESPACIO EN ESPACIO IDENTIFICADOR CORCHETEA INDICE_MATRIZ CORCHETEC FINAL 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("pintarMatriz", 13, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 10)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 28: // pintarArray ::= PINTAR ESPACIO COLOR ESPACIO EN ESPACIO IDENTIFICADOR CORCHETEA DIGITO CORCHETEC FINAL 
            {
                // Obtener el color
                String colorToken = (String) ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 8)).value; // Color como String
                Color color;

                // Mapear el token de color a un objeto Color
                switch (colorToken) {
                    case "rojo":
                        color = Color.RED;
                        break;
                    case "verde":
                        color = Color.GREEN;
                        break;
                    case "azul":
                        color = Color.BLUE;
                        break;
                    default:
                        color = Color.GRAY; // Color por defecto si no se reconoce
                        break;
                }

                // Obtener el identificador y el índice
                String identificador = (String) ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 4)).value; // Identificador
                int indice = (Integer) ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 2)).value; // Índice

                // Obtener la instancia del panel
                Panel panel = parser.getPanel(); // Aquí debes obtener la referencia a tu panel

                // Llamar al método para pintar la celda
                panel.pintarCeldaPorIdentificador(identificador, indice, color);

                Object RESULT = null;
                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("pintarArray", 12, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 10)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;
            /*. . . . . . . . . . . . . . . . . . . .*/
            case 27: // removerUltimo ::= REMOVER ESPACIO ULTIMO ESPACIO DE ESPACIO IDENTIFICADOR FINAL 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("removerUltimo", 11, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 7)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 26: // agregarValor ::= AGREGAR ESPACIO DIGITO ESPACIO A ESPACIO IDENTIFICADOR FINAL 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("agregarValor", 10, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 7)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 25: // eliminarMatriz ::= ELIMINAR ESPACIO IDENTIFICADOR CORCHETEA INDICE_MATRIZ CORCHETEC FINAL 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("eliminarMatriz", 9, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 6)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 24: // eliminarArray ::= ELIMINAR ESPACIO IDENTIFICADOR CORCHETEA DIGITO CORCHETEC FINAL
            {
                Object RESULT = null;

                String identificador = ((Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 4)).value.toString();
                String indiceString = ((Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 2)).value.toString();

                try {
                    int indice = Integer.parseInt(indiceString);

                    // Verifica si el identificador existe en las instrucciones
                    if (parser.getInstrucciones().containsKey(identificador)) {
                        Panel panel = parser.getPanel();
                        if (panel != null) {
                            // Lógica para eliminar el valor en la visualización correspondiente
                            panel.eliminarCeldaEnArray(identificador, indice); // Método que deberías implementar en Panel
                            RESULT = "Celda en " + identificador + "[" + indice + "] eliminada.";
                        } else {
                            RESULT = "Error: Panel no disponible.";
                        }
                    } else {
                        RESULT = "Error: El identificador '" + identificador + "' no existe.";
                    }
                } catch (NumberFormatException e) {
                    RESULT = "Error: El índice no es un número válido.";
                } catch (Exception e) {
                    RESULT = "Error al eliminar la celda: " + e.getMessage();
                }

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("eliminarArray", 8, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 6)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;


            /*. . . . . . . . . . . . . . . . . . . .*/
            case 23: // modificarMatriz ::= MODIFICAR ESPACIO IDENTIFICADOR CORCHETEA INDICE_MATRIZ CORCHETEC ESPACIO A ESPACIO DIGITO FINAL 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("modificarMatriz", 7, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 10)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 22: // modificarArray ::= MODIFICAR ESPACIO IDENTIFICADOR CORCHETEA DIGITO CORCHETEC ESPACIO A ESPACIO DIGITO FINAL 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("modificarArray", 6, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 10)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 21: // asignarValorMatriz ::= ASIGNAR ESPACIO DIGITO ESPACIO A ESPACIO IDENTIFICADOR CORCHETEA INDICE_MATRIZ CORCHETEC FINAL 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("asignarValorMatriz", 5, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 10)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 20: // asignarValorArray ::= ASIGNAR ESPACIO DIGITO ESPACIO A ESPACIO IDENTIFICADOR CORCHETEA DIGITO CORCHETEC FINAL 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("asignarValorArray", 4, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 10)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 19: // crearMatriz ::= CREAR ESPACIO MATRIZ ESPACIO IDENTIFICADOR CORCHETEA INDICE_MATRIZ CORCHETEC FINAL 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("crearMatriz", 3, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 8)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 18: // crearLista ::= CREAR ESPACIO LISTA ESPACIO IDENTIFICADOR CORCHETEA DIGITO CORCHETEC FINAL 
            {
                Object RESULT = null;
                String identificador = ((Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 4)).value.toString();
                String digitoString = ((Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 2)).value.toString();

                if (parser.getInstrucciones().containsKey(identificador)) {
                    RESULT = "Error: El identificador '" + identificador + "' ya existe.";
                } else {
                    try {
                        int tamano = Integer.parseInt(digitoString.trim());

                        if (identificador != null && tamano > 0) {
                            parser.agregarInstruccion(identificador, "crearLista");
                            Panel panel = parser.getPanel();
                            if (panel != null) {
                                panel.llenarCeldasAleatorias(tamano, panel.generarColorAleatorio(), identificador);
                            }
                            RESULT = "Lista '" + identificador + "' creada exitosamente.";
                        } else {
                            RESULT = "Error: el identificador o el tamaño no es válido.";
                        }
                    } catch (NumberFormatException e) {
                        RESULT = "Error: el tamaño no es un número válido.";
                    }
                }

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("crearLista", 2, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 8)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;


            /*. . . . . . . . . . . . . . . . . . . .*/
            case 17: // crearLista ::= CREAR ESPACIO LISTA ESPACIO IDENTIFICADOR CORCHETEA CORCHETEC FINAL 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("crearLista", 2, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 7)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 16: // crearArray ::= CREAR ESPACIO ARRAY ESPACIO IDENTIFICADOR CORCHETEA DIGITO CORCHETEC FINAL
            {
                Object RESULT = null;

                String identificador = ((Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 4)).value.toString();
                String digitoString = ((Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 2)).value.toString();

                System.out.println("Valor extraído de la pila: " + digitoString);

                try {
                    int tamano = Integer.parseInt(digitoString.trim());

                    if (identificador != null && tamano > 0) {
                        parser.agregarInstruccion(identificador, "crearArray");
                        System.out.println("Instrucción 'crearArray' añadida con éxito.");

                        // Accede al panel y cambia las celdas de color
                        Panel panel = parser.getPanel();
                        if (panel != null) {
                            panel.llenarCeldasAleatoriasSecuencialesMultiDireccion(tamano, panel.generarColorAleatorio(), identificador); // Puedes cambiar el color si lo deseas
                        }
                    } else {
                        System.out.println("Error: el identificador o el tamaño no es válido.");
                    }
                } catch (NumberFormatException e) {
                    System.out.println("Error: el tamaño no es un número válido.");
                }

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("crearArray", 1, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 8)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 15: // instruccion ::= vaciarEstructura 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("instruccion", 0, ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 14: // instruccion ::= mostrarEstructura 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("instruccion", 0, ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 13: // instruccion ::= pintarMatriz 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("instruccion", 0, ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 12: // instruccion ::= pintarArray 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("instruccion", 0, ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 11: // instruccion ::= removerUltimo 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("instruccion", 0, ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 10: // instruccion ::= agregarValor 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("instruccion", 0, ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 9: // instruccion ::= eliminarMatriz 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("instruccion", 0, ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 8: // instruccion ::= eliminarArray 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("instruccion", 0, ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 7: // instruccion ::= modificarMatriz 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("instruccion", 0, ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 6: // instruccion ::= modificarArray 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("instruccion", 0, ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 5: // instruccion ::= asignarValorMatriz 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("instruccion", 0, ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 4: // instruccion ::= asignarValorArray 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("instruccion", 0, ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 3: // instruccion ::= crearMatriz 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("instruccion", 0, ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 2: // instruccion ::= crearLista 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("instruccion", 0, ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 1: // instruccion ::= crearArray 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("instruccion", 0, ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 0: // $START ::= instruccion EOF 
            {
                Object RESULT = null;
                int start_valleft = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)).left;
                int start_valright = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)).right;
                Object start_val = (Object) ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)).value;
                RESULT = start_val;
                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("$START", 0, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            /* ACCEPT */
            CUP$Sintax$parser.done_parsing();
            return CUP$Sintax$result;

            /* . . . . . .*/
            default:
                throw new Exception(
                        "Invalid action number found in internal parse table");

        }
    }
}
